                                                                        《基础算法》
Num1-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
《排序》
**************************************************************
<冒泡排序>
#include<stdio.h>
int q[100000];
void quick_sort(int l, int r)
{
	if (l >= r)
		return;
	int x = q[l], i = l - 1, j = r + 1;
	while (i < j)
	{
		do i++; while (q[i] < x);
		do j--; while (q[j] > x);
		if (i < j)
		{
			int tmp = q[i];
			q[i] = q[j];
			q[j] = tmp;
		}
	}
	quick_sort(l, j);
	quick_sort(j+1, r);
}
int main()
{
	int n;
	scanf("%d", &n);
	for (int i = 0; i < n; i++)
		scanf("%d", &q[i]);
	quick_sort(0, n - 1);
	for (int i = 0; i < n; i++)                                    

		printf("%d ", q[i]);
	return 0;
}

问题1:递归时为什么不选其他的，非要选l,j和j+1,r
问题2:为什么l>=而不是l>r或者l==r
问题3:为什么x=q[l]
问题4:为什么是do while

一:
   1:如果是j,j 输入0,1第二个quick_sort的j,r还是0,1(死循环)
   2:如果是i,i 输入0,1第二个quick_sort的l,i还是0,1(死循环)
   3:      i,i+1 输入2 3 1输出结果错误(1 3 2)
   4:      j-1,j 输入1,2(死循环)
   5:      
二:当l=r 第一个quick_sort一直循环
三:l等价于(l+r)/2 ———— (l,j) (j+1,r)
   r等价于(l++r+1)/2 ———— (l,i-1) (i,r)
   这与quick_sort中j有关,前面j的取值就是因为这里限制的
四:如果是2 2 3 i和j最后都走不动了
******************************************************************

******************************************************************
<归并排序>

Num2-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
